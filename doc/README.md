# Сравнение производительности AVL и `std::set`
## Вставка строк
Результат тестирования в виде [таблицы](testCode/result/insertString.csv).

![График](/testCode/result/png/insertString.png)

На графике видно, что `std::set` проигрывает двум реализациям AVL и AVLTree. Несмотря на отсутствие рекурсии в первой реализации, она работает медленнее для `std::string`, судя по Perf'у, это из-за большого количества сравнений`std::string`.

## Удаление строк
Результат тестирования в виде [таблицы](testCode/result/deleteString.csv).

![График](/testCode/result/png/deleteString.png)

Мы получили аналогичный результат, но в этот раз различия между AVL и AVLTree не такие значительные, т.к. при операции `erase` происходит меньше сравнений `std::string`

## Вставка `int32`

Результат тестирования в виде [таблицы](testCode/result/insertNumber.csv).

![График](/testCode/result/png/insertNumber.png)

Наша реализация AVL работает быстрее `std::set`   
При увеличении количества вставляемых элементов различия в производительности растут и доходят до 30%.

## Удаление `int32`

Результат тестирования в виде [таблицы](testCode/result/deleteNumber.csv).

![График](/testCode/result/png/deleteNumber.png)

Наша реализация AVL работает быстрее `std::set`   
При увеличении количества удаляемых элементов различия в производительности растут и доходят до 50%.

## Порядковая статистика для `std::string`

Результат тестирования в виде [таблицы](testCode/result/stringOrderStatistic.csv).

![График](/testCode/result/png/stringOrderStatistic.png)

В данном случае наша реализация сравнивалась с реализацией из STL для GNU C++.  
В этот раз наша реализация проигрывает до 40%.

## Порядковая статистика для `int32`

Результат тестирования в виде [таблицы](testCode/result/numberOrderStatistic.csv).

![График](/testCode/result/png/numberOrderStatistic.png)

На числах наша реализация показывает прирост производительности до 50%.  
Честно говоря, сложно сказать, почему реализация stl на строках показывает такой хороший результат, а на числах проигрывает в несколько раз. Реализация метода `find_by_order(x)` практически идентична нашей реализации.

# Итог

Наша реализация показывает лучшие результаты для примитивных типов, сравнения которых обходятся дешёво. В случае же `std::string` мы получаем результат, который всё равно превосходит `std::set`, но проигрывает реализации с меньшим числом сравнений.  
